"""
GovStack API Integration Test Suite v2
Built from actual endpoint implementation analysis

Organization: Tech Innovators Network (THiNK)
URL: https://think.ke
API: https://govstack-api.think.ke
"""

import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any

from config import (
    test_results, validate_config, TEST_COLLECTION_NAME,
    TEST_COLLECTION_DESCRIPTION, TEST_ORG_NAME, TEST_ORG_URL,
    TEST_USER_ID, SKIP_LONG_RUNNING_TESTS, SKIP_CRAWL_TESTS,
    SKIP_CLEANUP, CRAWL_DEPTH, CRAWL_CONCURRENT_REQUESTS,
    CRAWL_FOLLOW_EXTERNAL, CRAWL_STRATEGY, TEST_DOCUMENT_DESCRIPTION,
    LOG_FILE, TEST_PDF_FILE, TEST_AUDIO_FILE
)
from logger import logger, log_test_summary
from api_client import client, admin_client


class GovStackTestSuite:
    """Complete integration test suite for GovStack API based on actual implementation"""
    
    def __init__(self):
        self.results = test_results
        self.test_data = {}  # Store created resources
        
    def run_test(self, test_name: str, test_func, *args, **kwargs):
        """Execute a single test with error handling"""
        logger.test_start(test_name)
        try:
            result = test_func(*args, **kwargs)
            if result:
                logger.test_pass(test_name, f"Response: {result.get('message', 'Success')}")
                self.results.add_pass()
            else:
                logger.test_fail(test_name, "Test returned False")
                self.results.add_fail(test_name)
            return result
        except Exception as e:
            logger.test_fail(test_name, str(e))
            self.results.add_fail(f"{test_name}: {str(e)}")
            return None
    
    # ========================================================================
    # 1. COLLECTIONS: Based on /collection-stats router
    # ========================================================================
    
    def test_create_collection(self):
        """POST /collection-stats/ - Create new collection"""
        logger.story("As an admin, I want to create a new collection")
        
        # Use timestamp to make collection name unique
        import time
        timestamp = int(time.time())
        unique_name = f"{TEST_COLLECTION_NAME}-{timestamp}"
        
        payload = {
            "name": unique_name,
            "description": TEST_COLLECTION_DESCRIPTION,
            "type": "mixed"  # documents|webpages|mixed
        }
        
        response = client.post("/collection-stats/", json=payload)
        
        if response["ok"]:
            data = response["data"]
            collection_id = data["id"]  # UUID generated by API
            self.test_data["collection_id"] = collection_id
            self.results.collection_id = collection_id
            logger.info(f"✅ Created collection: {collection_id}")
            logger.info(f"   Name: {data['name']}, Type: {data['type']}")
            return {"message": f"Collection created: {collection_id}"}
        else:
            raise Exception(f"Failed to create collection: {response['data']}")
    
    def test_list_collections(self):
        """GET /collection-stats/collections - List all collections"""
        logger.story("As a user, I want to view all existing collections")
        
        response = client.get("/collection-stats/collections")
        
        if response["ok"]:
            collections = response["data"]
            logger.info(f"✅ Retrieved {len(collections)} collections")
            
            # Find our test collection
            collection_id = self.test_data.get("collection_id")
            if collection_id:
                found = any(c["id"] == collection_id for c in collections)
                if found:
                    logger.info(f"✅ Found our test collection: {collection_id}")
            
            return {"message": f"Found {len(collections)} collections"}
        else:
            raise Exception(f"Failed to list collections: {response['data']}")
    
    def test_get_collection_stats(self):
        """GET /collection-stats/{collection_id} - Get collection statistics"""
        logger.story("As an analyst, I want to retrieve statistics for the collection")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        response = client.get(f"/collection-stats/{collection_id}")
        
        if response["ok"]:
            stats = response["data"]
            logger.info(f"✅ Collection stats:")
            logger.info(f"   Documents: {stats.get('total_documents', 0)}")
            logger.info(f"   Webpages: {stats.get('total_webpages', 0)}")
            logger.info(f"   Indexed: {stats.get('indexed_count', 'N/A')}")
            return {"message": "Collection stats retrieved"}
        else:
            raise Exception(f"Failed to get collection stats: {response['data']}")
    
    def test_update_collection(self):
        """PUT /collection-stats/{collection_id} - Update collection"""
        logger.story("As an admin, I want to update the collection metadata")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        # Use timestamp to ensure unique name
        import time
        timestamp = int(time.time() * 1000)  # milliseconds
        payload = {
            "name": f"{TEST_COLLECTION_NAME}-updated-{timestamp}",
            "description": f"{TEST_COLLECTION_DESCRIPTION} (Updated)"
        }
        
        response = client.put(f"/collection-stats/{collection_id}", json=payload)
        
        if response["ok"]:
            data = response["data"]
            logger.info(f"✅ Updated collection to: {data['name']}")
            return {"message": "Collection updated successfully"}
        else:
            raise Exception(f"Failed to update collection: {response['data']}")
    
    def test_get_collection_indexing_status(self):
        """GET /collection-stats/{collection_id}/indexing-status"""
        logger.story("As a developer, I want to check collection indexing status")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        response = client.get(f"/collection-stats/{collection_id}/indexing-status")
        
        if response["ok"]:
            status = response["data"]
            logger.info(f"✅ Indexing status:")
            logger.info(f"   Combined total: {status.get('combined', {}).get('total', 0)}")
            logger.info(f"   Combined indexed: {status.get('combined', {}).get('indexed', 0)}")
            logger.info(f"   Progress: {status.get('combined', {}).get('progress_percent', 0)}%")
            return {"message": "Indexing status retrieved"}
        else:
            raise Exception(f"Failed to get indexing status: {response['data']}")
    
    def test_get_all_collection_stats(self):
        """GET /collection-stats/ - Get all collection statistics"""
        logger.story("As an admin, I want to view statistics for all collections")
        
        response = client.get("/collection-stats/")
        
        if response["ok"]:
            stats = response["data"]
            logger.info(f"✅ Retrieved aggregate stats")
            return {"message": "All collection stats retrieved"}
        else:
            raise Exception(f"Failed to get all collection stats: {response['data']}")
    
    # ========================================================================
    # 2. DOCUMENTS: Based on document_router
    # ========================================================================
    
    def test_create_test_document(self):
        """Helper: Create test document file"""
        if not TEST_PDF_FILE.exists():
            raise Exception(f"Test PDF document not found: {TEST_PDF_FILE}")
        return TEST_PDF_FILE
    
    def test_upload_document(self):
        """POST /documents/ - Upload document"""
        logger.story("As a content manager, I want to upload a document")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        test_file = self.test_create_test_document()
        
        with open(test_file, "rb") as f:
            files = {"file": (test_file.name, f, "application/pdf")}
            data = {
                "description": TEST_DOCUMENT_DESCRIPTION,
                "is_public": "false",
                "collection_id": collection_id
            }
            
            response = client.post("/documents/", files=files, data=data)
        
        if response["ok"]:
            doc_data = response["data"]
            document_id = doc_data["id"]
            index_job_id = doc_data.get("index_job_id")
            
            self.test_data["document_id"] = document_id
            self.test_data["index_job_id"] = index_job_id
            self.results.document_id = document_id
            self.results.indexing_job_id = index_job_id
            
            logger.info(f"✅ Uploaded document:")
            logger.info(f"   ID: {document_id}")
            logger.info(f"   Filename: {doc_data.get('filename')}")
            logger.info(f"   Index Job: {index_job_id}")
            return {"message": f"Document uploaded: {document_id}"}
        else:
            raise Exception(f"Failed to upload document: {response['data']}")
    
    def test_list_documents(self):
        """GET /documents/ - List documents"""
        logger.story("As a user, I want to list all documents")
        
        response = client.get("/documents/", params={"skip": 0, "limit": 10})
        
        if response["ok"]:
            documents = response["data"]
            logger.info(f"✅ Retrieved {len(documents)} documents")
            if documents:
                logger.info(f"   Sample: {documents[0].get('filename', 'N/A')}")
            return {"message": f"Found {len(documents)} documents"}
        else:
            raise Exception(f"Failed to list documents: {response['data']}")
    
    def test_get_document(self):
        """GET /documents/{document_id} - Get document details"""
        logger.story("As a user, I want to retrieve document metadata")
        
        document_id = self.test_data.get("document_id")
        if not document_id:
            raise Exception("Document ID not found in test data")
        
        response = client.get(f"/documents/{document_id}")
        
        if response["ok"]:
            doc = response["data"]
            logger.info(f"✅ Document details:")
            logger.info(f"   Filename: {doc.get('filename')}")
            logger.info(f"   Indexed: {doc.get('is_indexed')}")
            logger.info(f"   Collection: {doc.get('collection_id')}")
            return {"message": "Document metadata retrieved"}
        else:
            raise Exception(f"Failed to get document: {response['data']}")
    
    def test_get_document_metadata(self):
        """GET /documents/{document_id}/metadata - Get metadata only"""
        logger.story("As a developer, I want to fetch just the metadata")
        
        document_id = self.test_data.get("document_id")
        if not document_id:
            raise Exception("Document ID not found in test data")
        
        response = client.get(f"/documents/{document_id}/metadata")
        
        if response["ok"]:
            metadata = response["data"]
            logger.info(f"✅ Document metadata retrieved")
            return {"message": "Metadata retrieved"}
        else:
            raise Exception(f"Failed to get metadata: {response['data']}")
    
    def test_update_document_metadata(self):
        """PATCH /documents/{document_id}/metadata - Update metadata"""
        logger.story("As a metadata editor, I want to update document metadata")
        
        document_id = self.test_data.get("document_id")
        if not document_id:
            raise Exception("Document ID not found in test data")
        
        payload = {
            "metadata": {
                "tags": ["immigration", "faq", "test", "think"],
                "category": "immigration-services",
                "organization": TEST_ORG_NAME,
                "source_url": TEST_ORG_URL,
                "reviewed": True,
                "test_run": True
            },
            "description": f"{TEST_DOCUMENT_DESCRIPTION} (Updated metadata)"
        }
        
        response = client.patch(f"/documents/{document_id}/metadata", json=payload)
        
        if response["ok"]:
            logger.info(f"✅ Updated document metadata")
            return {"message": "Document metadata updated"}
        else:
            raise Exception(f"Failed to update metadata: {response['data']}")
    
    def test_bulk_metadata_update(self):
        """POST /documents/bulk-metadata-update - Bulk update"""
        logger.story("As a bulk editor, I want to update multiple documents")
        
        document_id = self.test_data.get("document_id")
        if not document_id:
            raise Exception("Document ID not found in test data")
        
        payload = {
            "document_ids": [document_id],
            "metadata_updates": {
                "bulk_updated": True,
                "update_timestamp": datetime.now().isoformat(),
                "test_suite": "integration_tests_v2"
            }
        }
        
        response = client.post("/documents/bulk-metadata-update", json=payload)
        
        if response["ok"]:
            results = response["data"]
            logger.info(f"✅ Bulk update completed:")
            logger.info(f"   Updated: {results.get('updated_count', 0)}")
            logger.info(f"   Failed: {results.get('failed_count', 0)}")
            return {"message": "Bulk metadata update successful"}
        else:
            raise Exception(f"Failed bulk metadata update: {response['data']}")
    
    def test_list_documents_by_collection(self):
        """GET /documents/collection/{collection_id} - Filter by collection"""
        logger.story("As a user, I want to list documents in a specific collection")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        response = client.get(f"/documents/collection/{collection_id}")
        
        if response["ok"]:
            documents = response["data"]
            logger.info(f"✅ Found {len(documents)} documents in collection")
            return {"message": f"Found {len(documents)} documents"}
        else:
            raise Exception(f"Failed to list documents by collection: {response['data']}")
    
    def test_download_document(self):
        """GET /documents/{document_id}/download - Download file"""
        logger.story("As a user, I want to download the document file")
        
        document_id = self.test_data.get("document_id")
        if not document_id:
            raise Exception("Document ID not found in test data")
        
        response = client.get(f"/documents/{document_id}/download")
        
        if response["ok"]:
            # Response will be binary or redirect
            logger.info(f"✅ Document download link retrieved")
            return {"message": "Document download successful"}
        else:
            raise Exception(f"Failed to download document: {response['data']}")
    
    # ========================================================================
    # 3. INDEXING: Based on indexing_router
    # ========================================================================
    
    def test_trigger_indexing(self):
        """POST /indexing/trigger - Manually trigger indexing"""
        logger.story("As a backend engineer, I want to trigger indexing")
        
        # Note: This endpoint requires target_type and target_id (specific document or webpage)
        # Skipping as we don't have a document uploaded in this test run
        document_id = self.test_data.get("document_id")
        if not document_id:
            logger.warning("No document ID available, skipping manual indexing trigger")
            self.results.add_skip()
            return {"message": "Skipped - no document ID"}
        
        payload = {
            "target_type": "document",
            "target_id": int(document_id)  # Must be integer
        }
        
        response = client.post("/indexing/trigger", json=payload)
        
        if response["ok"]:
            data = response["data"]
            job_id = data.get("index_job_id")
            if job_id:
                self.test_data["manual_index_job_id"] = job_id
            logger.info(f"✅ Indexing triggered: {data.get('message')}")
            if job_id:
                logger.info(f"   Job ID: {job_id}")
            return {"message": "Indexing triggered"}
        else:
            raise Exception(f"Failed to trigger indexing: {response['data']}")
    
    def test_get_indexing_status(self):
        """GET /documents/indexing-status - Check document indexing status"""
        logger.story("As a QA tester, I want to check indexing status")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        response = client.get("/documents/indexing-status", params={"collection_id": collection_id})
        
        if response["ok"]:
            status = response["data"]
            logger.info(f"✅ Indexing status:")
            logger.info(f"   Total: {status.get('documents_total', 0)}")
            logger.info(f"   Indexed: {status.get('indexed', 0)}")
            logger.info(f"   Progress: {status.get('progress_percent', 0)}%")
            return {"message": "Indexing status retrieved"}
        else:
            raise Exception(f"Failed to get indexing status: {response['data']}")
    
    def test_list_indexing_jobs(self):
        """GET /documents/indexing-jobs - List indexing jobs"""
        logger.story("As a developer, I want to list all indexing jobs")
        
        # Note: Correct path is /documents/indexing-jobs (not /indexing/jobs)
        response = client.get("/documents/indexing-jobs", params={"limit": 10})
        
        if response["ok"]:
            jobs = response["data"]
            logger.info(f"✅ Retrieved {len(jobs)} indexing jobs")
            if jobs:
                latest = jobs[0]
                logger.info(f"   Latest: {latest.get('status')} - {latest.get('progress_percent', 0)}%")
            return {"message": f"Found {len(jobs)} jobs"}
        else:
            raise Exception(f"Failed to list indexing jobs: {response['data']}")
    
    def test_get_indexing_job_status(self):
        """GET /documents/indexing-jobs/{job_id} - Get specific job status"""
        logger.story("As a developer, I want to check a specific indexing job")
        
        job_id = self.test_data.get("index_job_id")
        if not job_id:
            logger.warning("No indexing job ID found, skipping test")
            self.results.add_skip()
            return {"message": "Skipped - no job ID"}
        
        # Wait for job completion
        result = client.wait_for_indexing_job(job_id, max_wait=120)
        
        if result["ok"]:
            job = result["data"]
            logger.info(f"✅ Job status: {job.get('status')}")
            logger.info(f"   Progress: {job.get('progress_percent', 0)}%")
            logger.info(f"   Message: {job.get('message', 'N/A')}")
            return {"message": f"Job status: {job.get('status')}"}
        else:
            raise Exception(f"Failed to get job status: {result['data']}")
    
    # ========================================================================
    # 4. WEBPAGES: Based on webpage_router  
    # ========================================================================
    
    def test_fetch_webpage(self):
        """POST /webpages/fetch-webpage/ - Fetch single webpage"""
        logger.story("As a researcher, I want to fetch a webpage")
        
        payload = {
            "url": TEST_ORG_URL,
            "skip_ssl_verification": False
        }
        
        response = client.post("/webpages/fetch-webpage/", json=payload)
        
        if response["ok"]:
            webpage = response["data"]
            title = webpage.get("title", "")[:50]
            logger.info(f"✅ Fetched webpage: {title}...")
            return {"message": f"Webpage fetched"}
        else:
            raise Exception(f"Failed to fetch webpage: {response['data']}")
    
    def test_list_webpages(self):
        """GET /webpages/ - List webpages"""
        logger.story("As a user, I want to list all fetched webpages")
        
        response = client.get("/webpages/", params={"limit": 10})
        
        if response["ok"]:
            webpages = response["data"]
            logger.info(f"✅ Retrieved {len(webpages)} webpages")
            
            # Store first webpage ID for later tests
            if webpages and len(webpages) > 0:
                self.test_data["webpage_id"] = webpages[0]["id"]
                self.results.webpage_id = webpages[0]["id"]
                logger.info(f"   Stored webpage ID: {webpages[0]['id']}")
            
            return {"message": f"Found {len(webpages)} webpages"}
        else:
            raise Exception(f"Failed to list webpages: {response['data']}")
    
    def test_get_webpage(self):
        """GET /webpages/{webpage_id} - Get webpage details"""
        logger.story("As a user, I want to retrieve webpage metadata")
        
        webpage_id = self.test_data.get("webpage_id")
        if not webpage_id:
            logger.warning("No webpage ID found, skipping test")
            self.results.add_skip()
            return {"message": "Skipped - no webpage ID"}
        
        response = client.get(f"/webpages/{webpage_id}", params={
            "include_content": False,
            "include_links": False
        })
        
        if response["ok"]:
            webpage = response["data"]
            logger.info(f"✅ Webpage details:")
            logger.info(f"   URL: {webpage.get('url', 'N/A')[:50]}")
            logger.info(f"   Title: {webpage.get('title', 'N/A')[:50]}")
            return {"message": "Webpage metadata retrieved"}
        else:
            raise Exception(f"Failed to get webpage: {response['data']}")
    
    def test_get_webpage_by_url(self):
        """GET /webpages/by-url/ - Find webpage by URL"""
        logger.story("As a user, I want to retrieve a webpage by its URL")
        
        response = client.get("/webpages/by-url/", params={"url": TEST_ORG_URL})
        
        if response["ok"]:
            webpage = response["data"]
            logger.info(f"✅ Found webpage by URL")
            
            # Store ID if not already stored
            if not self.test_data.get("webpage_id"):
                self.test_data["webpage_id"] = webpage["id"]
                self.results.webpage_id = webpage["id"]
            
            return {"message": "Webpage found by URL"}
        else:
            logger.warning(f"Webpage not found by URL (may not be indexed yet)")
            self.results.add_skip()
            return {"message": "Skipped - webpage not found"}
    
    def test_list_webpages_by_collection(self):
        """GET /webpages/collection/{collection_id} - Filter by collection"""
        logger.story("As a user, I want to list webpages in a collection")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        response = client.get(f"/webpages/collection/{collection_id}")
        
        if response["ok"]:
            webpages = response["data"]
            logger.info(f"✅ Found {len(webpages)} webpages in collection")
            return {"message": f"Found {len(webpages)} webpages"}
        else:
            raise Exception(f"Failed to list webpages by collection: {response['data']}")
    
    def test_recrawl_webpage(self):
        """POST /webpages/{webpage_id}/recrawl - Mark for recrawl"""
        logger.story("As a user, I want to recrawl a webpage")
        
        webpage_id = self.test_data.get("webpage_id")
        if not webpage_id:
            logger.warning("No webpage ID found, skipping test")
            self.results.add_skip()
            return {"message": "Skipped - no webpage ID"}
        
        response = client.post(f"/webpages/{webpage_id}/recrawl")
        
        if response["ok"]:
            logger.info(f"✅ Webpage marked for recrawl")
            return {"message": "Recrawl initiated"}
        else:
            raise Exception(f"Failed to recrawl webpage: {response['data']}")
    
    # ========================================================================
    # 5. WEB CRAWLER: Based on crawler_router
    # ========================================================================
    
    def test_start_crawl(self):
        """POST /crawl/ - Start website crawl"""
        logger.story("As a content analyst, I want to crawl a website")
        
        if SKIP_CRAWL_TESTS:
            logger.test_skip("Crawl test", "SKIP_CRAWL_TESTS=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        payload = {
            "url": TEST_ORG_URL,
            "depth": CRAWL_DEPTH,
            "concurrent_requests": CRAWL_CONCURRENT_REQUESTS,
            "follow_external": CRAWL_FOLLOW_EXTERNAL,
            "strategy": CRAWL_STRATEGY,
            "collection_id": collection_id
        }
        
        response = client.post("/crawl/", json=payload)
        
        if response["ok"]:
            data = response["data"]
            task_id = data.get("task_id")
            self.test_data["crawl_task_id"] = task_id
            self.results.crawl_task_id = task_id
            
            logger.info(f"✅ Started crawl:")
            logger.info(f"   Task ID: {task_id}")
            logger.info(f"   URL: {TEST_ORG_URL}")
            logger.info(f"   Depth: {CRAWL_DEPTH}")
            return {"message": f"Crawl started: {task_id}"}
        else:
            raise Exception(f"Failed to start crawl: {response['data']}")
    
    def test_list_crawl_jobs(self):
        """GET /crawl/ - List crawl jobs"""
        logger.story("As a user, I want to list all crawl jobs")
        
        if SKIP_CRAWL_TESTS:
            logger.test_skip("Crawl jobs list", "SKIP_CRAWL_TESTS=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        response = client.get("/crawl/")
        
        if response["ok"]:
            jobs = response["data"]
            logger.info(f"✅ Retrieved {len(jobs)} crawl jobs")
            return {"message": f"Found {len(jobs)} jobs"}
        else:
            raise Exception(f"Failed to list crawl jobs: {response['data']}")
    
    def test_get_crawl_status(self):
        """GET /crawl/{task_id} - Get crawl status"""
        logger.story("As a user, I want to check crawl status")
        
        if SKIP_CRAWL_TESTS:
            logger.test_skip("Crawl status", "SKIP_CRAWL_TESTS=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        task_id = self.test_data.get("crawl_task_id")
        if not task_id:
            logger.warning("No crawl task ID found, skipping test")
            self.results.add_skip()
            return {"message": "Skipped - no task ID"}
        
        # Wait for crawl to make progress
        result = client.wait_for_crawl_completion(task_id, max_wait=180)
        
        if result["ok"]:
            crawl = result["data"]
            logger.info(f"✅ Crawl status:")
            logger.info(f"   Status: {crawl.get('status')}")
            logger.info(f"   URLs crawled: {crawl.get('urls_crawled', 0)}")
            logger.info(f"   Finished: {crawl.get('finished', False)}")
            return {"message": f"Crawl status retrieved"}
        else:
            logger.warning(f"Crawl check: {result['data']}")
            return {"message": "Crawl in progress or timeout"}
    
    # ========================================================================
    # 6. CHAT: Based on chat_router (from endpoints/chat_endpoints.py)
    # ========================================================================
    
    def test_chat_query(self):
        """POST /chat/ - Send chat message"""
        logger.story("As a citizen, I want to ask a question")
        
        payload = {
            "message": "What documents are required for immigration?",
            "user_id": TEST_USER_ID,
            "metadata": {
                "test": "integration_v2",
                "organization": TEST_ORG_NAME
            }
        }
        
        response = client.post("/chat/", json=payload)
        
        if response["ok"]:
            data = response["data"]
            session_id = data.get("session_id")
            answer = data.get("answer", "")[:100]
            
            self.test_data["session_id"] = session_id
            self.results.session_id = session_id
            
            # Try to extract message_id from assistant messages
            messages = data.get("messages", [])
            if messages:
                # Look for the last assistant message
                for msg in reversed(messages):
                    if msg.get("message_type") == "assistant":
                        msg_id = msg.get("message_id")
                        if msg_id:
                            self.test_data["message_id"] = msg_id
                            self.results.message_id = msg_id
                            logger.info(f"   Message ID: {msg_id}")
                            break
            
            logger.info(f"✅ Chat response received:")
            logger.info(f"   Session: {session_id}")
            logger.info(f"   Answer: {answer}...")
            return {"message": "Chat response received"}
        else:
            raise Exception(f"Failed to send chat message: {response['data']}")
    
    def test_agency_scoped_chat(self):
        """POST /chat/{agency} - Agency-scoped chat"""
        logger.story("As a user, I want to route to a specific agency")
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            raise Exception("Collection ID not found in test data")
        
        payload = {
            "message": "What are the visa requirements?",
            "user_id": TEST_USER_ID,
            "metadata": {"test": "integration_v2_agency"}
        }
        
        response = client.post(f"/chat/{collection_id}", json=payload)
        
        if response["ok"]:
            data = response["data"]
            answer = data.get("answer", "")[:100]
            logger.info(f"✅ Agency-scoped response: {answer}...")
            return {"message": "Agency-scoped chat successful"}
        else:
            raise Exception(f"Failed agency-scoped chat: {response['data']}")
    
    def test_get_chat_history(self):
        """GET /chat/{session_id} - Get chat history"""
        logger.story("As a user, I want to retrieve chat history")
        
        session_id = self.test_data.get("session_id")
        if not session_id:
            raise Exception("Session ID not found in test data")
        
        response = client.get(f"/chat/{session_id}")
        
        if response["ok"]:
            history = response["data"]
            message_count = history.get("message_count", 0)
            logger.info(f"✅ Chat history: {message_count} messages")
            return {"message": f"Retrieved {message_count} messages"}
        else:
            raise Exception(f"Failed to get chat history: {response['data']}")
    
    def test_get_chat_events(self):
        """GET /chat/events/{session_id} - Get chat events"""
        logger.story("As a developer, I want to retrieve chat events")
        
        session_id = self.test_data.get("session_id")
        if not session_id:
            raise Exception("Session ID not found in test data")
        
        response = client.get(f"/chat/events/{session_id}", params={"limit": 50})
        
        if response["ok"]:
            data = response["data"]
            events = data.get("events", [])
            logger.info(f"✅ Retrieved {len(events)} chat events")
            return {"message": f"Retrieved {len(events)} events"}
        else:
            raise Exception(f"Failed to get chat events: {response['data']}")
    
    def test_get_latest_chat_events(self):
        """GET /chat/events/{session_id}/latest - Get latest events"""
        logger.story("As a developer, I want to get latest events")
        
        session_id = self.test_data.get("session_id")
        if not session_id:
            raise Exception("Session ID not found in test data")
        
        response = client.get(f"/chat/events/{session_id}/latest", params={"count": 5})
        
        if response["ok"]:
            data = response["data"]
            events = data.get("events", [])
            logger.info(f"✅ Retrieved {len(events)} latest events")
            return {"message": f"Retrieved {len(events)} latest events"}
        else:
            raise Exception(f"Failed to get latest events: {response['data']}")
    
    # ========================================================================
    # 7. RATINGS: Based on rating_router (prefix=/chat)
    # ========================================================================
    
    def test_submit_rating(self):
        """POST /chat/ratings - Submit rating"""
        logger.story("As a user, I want to rate the chatbot response")
        
        session_id = self.test_data.get("session_id")
        message_id = self.test_data.get("message_id")
        
        if not session_id:
            raise Exception("Session ID not found in test data")
        
        if not message_id:
            logger.warning("No assistant message ID found, skipping rating test")
            self.results.add_skip()
            return {"message": "Skipped - no message ID"}
        
        payload = {
            "session_id": session_id,
            "message_id": message_id,
            "rating": 5,
            "feedback_text": "Excellent response! Very helpful and accurate.",
            "user_id": TEST_USER_ID,
            "metadata": {"test": "integration_v2", "helpful": True}
        }
        
        response = client.post("/chat/ratings", json=payload)
        
        if response["ok"]:
            data = response["data"]
            rating_id = data.get("id")
            self.test_data["rating_id"] = rating_id
            self.results.rating_id = rating_id
            
            logger.info(f"✅ Rating submitted: ID={rating_id}, Rating=5")
            return {"message": f"Rating submitted: {rating_id}"}
        else:
            raise Exception(f"Failed to submit rating: {response['data']}")
    
    def test_list_ratings(self):
        """GET /chat/ratings - List ratings"""
        logger.story("As an admin, I want to list all ratings")
        
        # Note: session_id is optional - can list all ratings
        response = client.get("/chat/ratings", params={"limit": 10})
        
        if response["ok"]:
            ratings = response["data"]
            logger.info(f"✅ Retrieved {len(ratings)} ratings")
            if ratings:
                logger.info(f"   Sample rating: {ratings[0].get('rating')}/5")
            return {"message": f"Found {len(ratings)} ratings"}
        else:
            raise Exception(f"Failed to list ratings: {response['data']}")
    
    def test_get_rating(self):
        """GET /chat/ratings/{rating_id} - Get specific rating"""
        logger.story("As an admin, I want to retrieve a specific rating")
        
        rating_id = self.test_data.get("rating_id")
        if not rating_id:
            logger.warning("No rating ID found, skipping test")
            self.results.add_skip()
            return {"message": "Skipped - no rating ID"}
        
        response = client.get(f"/chat/ratings/{rating_id}")
        
        if response["ok"]:
            rating = response["data"]
            logger.info(f"✅ Rating details: {rating.get('rating')}/5")
            logger.info(f"   Feedback: {rating.get('feedback_text', '')[:50]}")
            return {"message": "Rating retrieved"}
        else:
            raise Exception(f"Failed to get rating: {response['data']}")
    
    def test_update_rating(self):
        """PUT /chat/ratings/{rating_id} - Update rating"""
        logger.story("As a user, I want to update my rating")
        
        rating_id = self.test_data.get("rating_id")
        if not rating_id:
            logger.warning("No rating ID found, skipping test")
            self.results.add_skip()
            return {"message": "Skipped - no rating ID"}
        
        payload = {
            "rating": 4,
            "feedback_text": "Updated: Good response, could be more detailed."
        }
        
        response = client.put(f"/chat/ratings/{rating_id}", json=payload)
        
        if response["ok"]:
            logger.info(f"✅ Rating updated to 4/5")
            return {"message": "Rating updated"}
        else:
            raise Exception(f"Failed to update rating: {response['data']}")
    
    def test_get_rating_stats(self):
        """GET /chat/ratings/stats - Get rating statistics"""
        logger.story("As an admin, I want to view rating statistics")
        
        # Note: /ratings/stats not /{rating_id}/stats
        response = client.get("/chat/ratings/stats")
        
        if response["ok"]:
            stats = response["data"]
            logger.info(f"✅ Rating stats:")
            logger.info(f"   Total: {stats.get('total_ratings', 0)}")
            logger.info(f"   Average: {stats.get('average_rating', 0):.2f}")
            return {"message": "Rating stats retrieved"}
        else:
            raise Exception(f"Failed to get rating stats: {response['data']}")
    
    # ========================================================================
    # 8. AUDIT LOGS: Based on audit_router (prefix=/admin)
    # ========================================================================
    
    def test_list_audit_logs(self):
        """GET /admin/audit-logs - List audit logs"""
        logger.story("As a compliance officer, I want to list audit logs")
        
        response = admin_client.get("/admin/audit-logs", params={"limit": 20})
        
        if response["ok"]:
            logs = response["data"]
            logger.info(f"✅ Retrieved {len(logs)} audit logs")
            if logs:
                logger.info(f"   Latest action: {logs[0].get('action')}")
            return {"message": f"Found {len(logs)} logs"}
        else:
            raise Exception(f"Failed to list audit logs: {response['data']}")
    
    def test_get_audit_summary(self):
        """GET /admin/audit-logs/summary - Get audit summary"""
        logger.story("As a compliance officer, I want audit summary")
        
        response = admin_client.get("/admin/audit-logs/summary")
        
        if response["ok"]:
            summary = response["data"]
            logger.info(f"✅ Audit summary:")
            logger.info(f"   Total actions: {summary.get('total_actions', 0)}")
            logger.info(f"   Unique users: {summary.get('unique_users', 0)}")
            return {"message": "Audit summary retrieved"}
        else:
            raise Exception(f"Failed to get audit summary: {response['data']}")
    
    def test_get_user_audit_logs(self):
        """GET /admin/audit-logs/user/{user_id} - Get user logs"""
        logger.story("As an admin, I want to view logs for a specific user")
        
        response = admin_client.get(f"/admin/audit-logs/user/{TEST_USER_ID}", params={"limit": 10})
        
        if response["ok"]:
            logs = response["data"]
            logger.info(f"✅ Retrieved {len(logs)} logs for user {TEST_USER_ID}")
            return {"message": f"Found {len(logs)} logs"}
        else:
            raise Exception(f"Failed to get user audit logs: {response['data']}")
    
    def test_get_resource_audit_logs(self):
        """GET /admin/audit-logs/resource/{type}/{id} - Get resource logs"""
        logger.story("As an admin, I want to view logs for a resource")
        
        document_id = self.test_data.get("document_id")
        if not document_id:
            logger.warning("No document ID found, skipping test")
            self.results.add_skip()
            return {"message": "Skipped - no document ID"}
        
        response = admin_client.get(f"/admin/audit-logs/resource/document/{document_id}")
        
        if response["ok"]:
            logs = response["data"]
            logger.info(f"✅ Retrieved {len(logs)} logs for document {document_id}")
            return {"message": f"Found {len(logs)} logs"}
        else:
            raise Exception(f"Failed to get resource logs: {response['data']}")
    
    # ========================================================================
    # 9. TRANSCRIPTIONS: Based on transcription_router
    # ========================================================================
    
    def test_upload_transcription(self):
        """POST /transcriptions/ - Upload audio for transcription"""
        logger.story("As a user, I want to transcribe an audio file")
        
        if not TEST_AUDIO_FILE.exists():
            logger.warning(f"Test audio file not found: {TEST_AUDIO_FILE}")
            self.results.add_skip()
            return {"message": "Skipped - no audio file"}
        
        with open(TEST_AUDIO_FILE, "rb") as f:
            files = {"file": (TEST_AUDIO_FILE.name, f, "audio/mpeg")}
            data = {
                "metadata": '{"test": "integration_v2", "language": "swahili"}'
            }
            
            response = client.post("/transcriptions/", files=files, data=data)
        
        if response["ok"]:
            transcription_data = response["data"]["transcription"]
            transcription_id = transcription_data["id"]
            status = transcription_data.get("status", "unknown")
            
            self.test_data["transcription_id"] = transcription_id
            self.results.transcription_id = transcription_id
            
            logger.info(f"✅ Uploaded audio for transcription:")
            logger.info(f"   ID: {transcription_id}")
            logger.info(f"   Status: {status}")
            logger.info(f"   File: {TEST_AUDIO_FILE.name}")
            return {"message": f"Transcription started: {transcription_id}"}
        else:
            raise Exception(f"Failed to upload transcription: {response['data']}")
    
    def test_get_transcription(self):
        """GET /transcriptions/{transcription_id} - Get transcription status"""
        logger.story("As a user, I want to check transcription status")
        
        transcription_id = self.test_data.get("transcription_id")
        if not transcription_id:
            logger.warning("No transcription ID available, skipping")
            self.results.add_skip()
            return {"message": "Skipped - no transcription ID"}
        
        response = client.get(f"/transcriptions/{transcription_id}")
        
        if response["ok"]:
            data = response["data"]
            status = data.get("status", "unknown")
            text = data.get("text", "")[:100] if data.get("text") else "N/A"
            
            logger.info(f"✅ Transcription status:")
            logger.info(f"   Status: {status}")
            logger.info(f"   Text preview: {text}...")
            return {"message": f"Transcription {status}"}
        else:
            raise Exception(f"Failed to get transcription: {response['data']}")
    
    def test_list_transcriptions(self):
        """GET /transcriptions/ - List transcriptions"""
        logger.story("As a user, I want to list transcriptions")
        
        response = client.get("/transcriptions/", params={"limit": 10})
        
        if response["ok"]:
            transcriptions = response["data"]
            logger.info(f"✅ Retrieved {len(transcriptions)} transcriptions")
            return {"message": f"Found {len(transcriptions)} transcriptions"}
        else:
            raise Exception(f"Failed to list transcriptions: {response['data']}")
    
    # ========================================================================
    # CLEANUP: Remove test data
    # ========================================================================
    
    def test_delete_rating(self):
        """DELETE /chat/ratings/{rating_id} - Delete rating"""
        logger.story("As a user, I want to delete my rating")
        
        if SKIP_CLEANUP:
            logger.test_skip("Delete rating", "SKIP_CLEANUP=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        rating_id = self.test_data.get("rating_id")
        if not rating_id:
            logger.warning("No rating ID found, skipping")
            self.results.add_skip()
            return {"message": "Skipped - no rating ID"}
        
        response = client.delete(f"/chat/ratings/{rating_id}")
        
        if response["ok"]:
            logger.info(f"✅ Rating deleted")
            return {"message": "Rating deleted"}
        else:
            raise Exception(f"Failed to delete rating: {response['data']}")
    
    def test_delete_chat_session(self):
        """DELETE /chat/{session_id} - Delete chat session"""
        logger.story("As a user, I want to delete my chat session")
        
        if SKIP_CLEANUP:
            logger.test_skip("Delete chat", "SKIP_CLEANUP=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        session_id = self.test_data.get("session_id")
        if not session_id:
            logger.warning("No session ID found, skipping")
            self.results.add_skip()
            return {"message": "Skipped - no session ID"}
        
        response = client.delete(f"/chat/{session_id}")
        
        if response["ok"]:
            logger.info(f"✅ Chat session deleted")
            return {"message": "Chat session deleted"}
        else:
            raise Exception(f"Failed to delete chat: {response['data']}")
    
    def test_delete_webpage(self):
        """DELETE /webpages/{webpage_id} - Delete webpage"""
        logger.story("As an admin, I want to delete a webpage")
        
        if SKIP_CLEANUP:
            logger.test_skip("Delete webpage", "SKIP_CLEANUP=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        webpage_id = self.test_data.get("webpage_id")
        if not webpage_id:
            logger.warning("No webpage ID found, skipping")
            self.results.add_skip()
            return {"message": "Skipped - no webpage ID"}
        
        response = client.delete(f"/webpages/{webpage_id}")
        
        if response["ok"]:
            logger.info(f"✅ Webpage deleted")
            return {"message": "Webpage deleted"}
        else:
            logger.warning(f"Webpage deletion: {response['data']}")
            return {"message": "Webpage deletion attempted"}
    
    def test_delete_document(self):
        """DELETE /documents/{document_id} - Delete document"""
        logger.story("As an admin, I want to delete the test document")
        
        if SKIP_CLEANUP:
            logger.test_skip("Delete document", "SKIP_CLEANUP=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        document_id = self.test_data.get("document_id")
        if not document_id:
            logger.warning("No document ID found, skipping")
            self.results.add_skip()
            return {"message": "Skipped - no document ID"}
        
        response = client.delete(f"/documents/{document_id}")
        
        if response["ok"]:
            logger.info(f"✅ Document deleted")
            return {"message": "Document deleted"}
        else:
            raise Exception(f"Failed to delete document: {response['data']}")
    
    def test_delete_collection(self):
        """DELETE /collection-stats/{collection_id} - Delete collection"""
        logger.story("As an admin, I want to delete the test collection")
        
        if SKIP_CLEANUP:
            logger.test_skip("Delete collection", "SKIP_CLEANUP=true")
            self.results.add_skip()
            return {"message": "Skipped"}
        
        collection_id = self.test_data.get("collection_id")
        if not collection_id:
            logger.warning("No collection ID found, skipping")
            self.results.add_skip()
            return {"message": "Skipped - no collection ID"}
        
        response = client.delete(f"/collection-stats/{collection_id}")
        
        if response["ok"]:
            logger.info(f"✅ Collection deleted")
            return {"message": "Collection deleted"}
        else:
            raise Exception(f"Failed to delete collection: {response['data']}")
    
    # ========================================================================
    # TEST RUNNER
    # ========================================================================
    
    def run_all_tests(self):
        """Execute all tests in chronological order"""
        logger.section("GOVSTACK API INTEGRATION TEST SUITE V2")
        logger.info(f"Testing Organization: {TEST_ORG_NAME}")
        logger.info(f"Organization URL: {TEST_ORG_URL}")
        logger.info(f"Base URL: {client.base_url}")
        logger.info(f"Test started at: {datetime.now().isoformat()}")
        
        # Health check first
        logger.section("0. HEALTH CHECK")
        if not client.health_check():
            logger.critical("API health check failed! Cannot proceed.")
            sys.exit(1)
        logger.info("✅ API is healthy")
        
        # 1. Collections
        logger.section("1. COLLECTIONS")
        self.run_test("Create Collection", self.test_create_collection)
        self.run_test("List Collections", self.test_list_collections)
        self.run_test("Get Collection Stats", self.test_get_collection_stats)
        self.run_test("Update Collection", self.test_update_collection)
        self.run_test("Get Collection Indexing Status", self.test_get_collection_indexing_status)
        self.run_test("Get All Collection Stats", self.test_get_all_collection_stats)
        
        # 2. Documents
        logger.section("2. DOCUMENTS")
        self.run_test("Upload Document", self.test_upload_document)
        self.run_test("List Documents", self.test_list_documents)
        self.run_test("Get Document", self.test_get_document)
        self.run_test("Get Document Metadata", self.test_get_document_metadata)
        self.run_test("Update Document Metadata", self.test_update_document_metadata)
        self.run_test("Bulk Metadata Update", self.test_bulk_metadata_update)
        self.run_test("List Documents by Collection", self.test_list_documents_by_collection)
        self.run_test("Download Document", self.test_download_document)
        
        # 3. Indexing
        logger.section("3. INDEXING")
        self.run_test("Trigger Indexing", self.test_trigger_indexing)
        self.run_test("Get Indexing Status", self.test_get_indexing_status)
        self.run_test("List Indexing Jobs", self.test_list_indexing_jobs)
        self.run_test("Get Indexing Job Status", self.test_get_indexing_job_status)
        
        # 4. Webpages
        logger.section("4. WEBPAGES")
        self.run_test("Fetch Webpage", self.test_fetch_webpage)
        self.run_test("List Webpages", self.test_list_webpages)
        self.run_test("Get Webpage", self.test_get_webpage)
        self.run_test("Get Webpage by URL", self.test_get_webpage_by_url)
        self.run_test("List Webpages by Collection", self.test_list_webpages_by_collection)
        self.run_test("Recrawl Webpage", self.test_recrawl_webpage)
        
        # 5. Web Crawler
        logger.section("5. WEB CRAWLER")
        self.run_test("Start Crawl", self.test_start_crawl)
        self.run_test("List Crawl Jobs", self.test_list_crawl_jobs)
        self.run_test("Get Crawl Status", self.test_get_crawl_status)
        
        # 6. Chat
        logger.section("6. CHAT")
        self.run_test("Send Chat Query", self.test_chat_query)
        self.run_test("Agency-Scoped Chat", self.test_agency_scoped_chat)
        self.run_test("Get Chat History", self.test_get_chat_history)
        self.run_test("Get Chat Events", self.test_get_chat_events)
        self.run_test("Get Latest Chat Events", self.test_get_latest_chat_events)
        
        # 7. Ratings
        logger.section("7. RATINGS")
        self.run_test("Submit Rating", self.test_submit_rating)
        self.run_test("List Ratings", self.test_list_ratings)
        self.run_test("Get Rating", self.test_get_rating)
        self.run_test("Update Rating", self.test_update_rating)
        self.run_test("Get Rating Stats", self.test_get_rating_stats)
        
        # 8. Audit Logs
        logger.section("8. AUDIT LOGS")
        self.run_test("List Audit Logs", self.test_list_audit_logs)
        self.run_test("Get Audit Summary", self.test_get_audit_summary)
        self.run_test("Get User Audit Logs", self.test_get_user_audit_logs)
        self.run_test("Get Resource Audit Logs", self.test_get_resource_audit_logs)
        
        # 9. Transcriptions
        logger.section("9. TRANSCRIPTIONS")
        self.run_test("Upload Transcription", self.test_upload_transcription)
        self.run_test("Get Transcription", self.test_get_transcription)
        self.run_test("List Transcriptions", self.test_list_transcriptions)
        
        # Cleanup
        logger.section("CLEANUP")
        self.run_test("Delete Rating", self.test_delete_rating)
        self.run_test("Delete Chat Session", self.test_delete_chat_session)
        self.run_test("Delete Webpage", self.test_delete_webpage)
        self.run_test("Delete Document", self.test_delete_document)
        self.run_test("Delete Collection", self.test_delete_collection)
        
        # Summary
        summary = self.results.summary()
        log_test_summary(summary)
        
        logger.info(f"\nTest completed at: {datetime.now().isoformat()}")
        logger.info(f"Logs saved to: {LOG_FILE}")
        
        return summary


def main():
    """Main entry point"""
    try:
        # Validate configuration
        validate_config()
        
        # Create and run test suite
        suite = GovStackTestSuite()
        summary = suite.run_all_tests()
        
        # Exit with appropriate code
        if summary["failed"] > 0:
            sys.exit(1)
        else:
            sys.exit(0)
            
    except KeyboardInterrupt:
        logger.warning("\n⚠️  Test execution interrupted by user")
        sys.exit(130)
    except Exception as e:
        logger.critical(f"Fatal error: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
